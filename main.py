# ===================================================================
# ПРОВЕРКА И УСТАНОВКА БИБЛИОТЕК
# ===================================================================
# Эта часть кода проверяет наличие необходимых библиотек
# и автоматически устанавливает их, если они отсутствуют

import subprocess  # Для выполнения команд в системе
import sys  # Для работы с системными параметрами

def check_and_install_package(package_name, import_name=None):
    """
    Проверяет наличие библиотеки и устанавливает её, если отсутствует
    
    Аргументы:
        package_name (str): имя пакета для установки через pip
        import_name (str): имя для импорта (если отличается от package_name)
    """
    # Если import_name не указан, используем package_name
    if import_name is None:
        import_name = package_name
    
    try:
        # Пытаемся импортировать библиотеку
        # __import__() - встроенная функция Python для динамического импорта
        __import__(import_name)
        print(f"✅ Библиотека '{package_name}' уже установлена")
    except ImportError:
        # Если библиотека не найдена, устанавливаем её
        print(f"⚠️  Библиотека '{package_name}' не найдена. Устанавливаю...")
        try:
            # Устанавливаем библиотеку через pip
            # sys.executable - путь к интерпретатору Python
            # subprocess.check_call() выполняет команду в терминале
            # stdout=subprocess.DEVNULL - скрываем вывод установки
            subprocess.check_call(
                [sys.executable, "-m", "pip", "install", package_name, "--quiet"],
                stdout=subprocess.DEVNULL,  # Не показываем вывод установки
                stderr=subprocess.DEVNULL
            )
            # После установки пытаемся снова импортировать
            try:
                __import__(import_name)
                print(f"✅ Библиотека '{package_name}' успешно установлена и проверена!")
            except ImportError:
                # Если после установки всё равно не импортируется
                print(f"⚠️  Библиотека '{package_name}' установлена, но импорт не удался")
                print(f"   Возможно, требуется перезапуск программы")
        except subprocess.CalledProcessError:
            # Если установка не удалась, выводим ошибку
            print(f"❌ Ошибка при установке библиотеки '{package_name}'")
            print(f"   Попробуйте установить вручную: pip install {package_name}")
            sys.exit(1)  # Завершаем программу с ошибкой

# Проверяем и устанавливаем необходимые библиотеки
print("=" * 60)
print("ПРОВЕРКА НЕОБХОДИМЫХ БИБЛИОТЕК")
print("=" * 60)
check_and_install_package("scikit-learn", "sklearn")  # sklearn - это scikit-learn
check_and_install_package("matplotlib")
check_and_install_package("numpy")
print("=" * 60)
print("✅ Все библиотеки готовы к работе!\n")

# ===================================================================
# ИМПОРТ БИБЛИОТЕК
# ===================================================================
# Теперь импортируем библиотеки (они точно установлены)

from sklearn.linear_model import LogisticRegression  # Модель для классификации
import matplotlib.pyplot as plt  # Для создания графиков
from mpl_toolkits.mplot3d import Axes3D  # Для 3D графиков
import numpy as np  # Для работы с массивами и числами
from matplotlib import animation  # Для создания анимации

# ===================================================================
# ЧАСТЬ 1: ПОДГОТОВКА ДАННЫХ ДЛЯ ОБУЧЕНИЯ
# ===================================================================

# Список предложений (строк) для обучения модели
# Каждое предложение состоит из слов "аак", "бик", "хрясь"
train_sentences = [
    "аак аак аак",                  # радостно (много "аак")
    "аак аак бик",                  # радостно
    "аак бик хрясь",                # радостно
    "бик бик",                      # грустно (много "бик")
    "бик бик бик хрясь",            # грустно
    "бик аак бик",                  # грустно
    "аак аак аак аак хрясь",        # радостно
    "бик бик бик бик хрясь хрясь",  # грустно
    "бик бик бик  хрясь хрясь",     # грустно
    "бик  бик бик хрясь хрясь",     # грустно
    "бик бик бик бик хрясь хрясь",  # грустно
    "бик бик бик бик  хрясь",       # грустно
    "бик бик бик бик хрясь хрясь",  # грустно
    "бик аак аак аак аак бик бик бик хрясь хрясь",  # грустно
]

# Список правильных ответов (метки) для каждого предложения
# 1 = радостно, 0 = грустно
# Порядок соответствует порядку предложений в train_sentences
y = [1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]

# Функция для извлечения признаков (features) из предложения
# Признаки - это характеристики, которые модель использует для обучения
def extract_features(sentence: str):
    """
    Преобразует предложение в список чисел (признаков)
    
    Аргументы:
        sentence (str): предложение из слов "аак", "бик", "хрясь"
    
    Возвращает:
        list: список из трех чисел [количество_аак, количество_бик, количество_хрясь]
    """
    # Разбиваем предложение на отдельные слова
    # Например: "аак аак бик" -> ["аак", "аак", "бик"]
    words = sentence.split()
    
    # Считаем, сколько раз встречается слово "аак"
    # sum(1 for w in words if w == "аак") - это генератор, который
    # создает единицу для каждого слова "аак", а sum() их складывает
    count_aak = sum(1 for w in words if w == "аак")
    
    # Считаем, сколько раз встречается слово "бик"
    count_bik = sum(1 for w in words if w == "бик")
    
    # Считаем, сколько раз встречается слово "хрясь"
    count_hrjas = sum(1 for w in words if w == "хрясь")
    
    # Возвращаем список из трех чисел
    return [count_aak, count_bik, count_hrjas]

# Преобразуем все предложения в признаки
# [extract_features(s) for s in train_sentences] - это list comprehension
# (списковое включение), которое применяет функцию extract_features
# к каждому предложению в train_sentences
# np.array() преобразует список списков в массив NumPy для удобной работы
X = np.array([extract_features(s) for s in train_sentences])

# ===================================================================
# ЧАСТЬ 2: ОБУЧЕНИЕ МОДЕЛИ
# ===================================================================

# Создаем модель логистической регрессии
# Это алгоритм машинного обучения, который умеет классифицировать
# (разделять на классы: радостно/грустно)
model = LogisticRegression()

# Обучаем модель на наших данных
# X - признаки (сколько раз встречается каждое слово)
# y - правильные ответы (радостно или грустно)
# После обучения модель "запомнит" закономерности
model.fit(X, y)

# ===================================================================
# ЧАСТЬ 3: СОЗДАНИЕ 3D ГРАФИКА
# ===================================================================

# Создаем новую фигуру (окно для графика) размером 8x7 дюймов
fig = plt.figure(figsize=(8, 7))

# Создаем 3D систему координат (оси X, Y, Z)
# 111 означает: 1 строка, 1 колонка, 1-й график
ax = fig.add_subplot(111, projection="3d")

# Извлекаем данные для каждой оси из массива X
# X[:, 0] - берем все строки (:) и 0-й столбец (количество "аак")
# X[:, 1] - все строки, 1-й столбец (количество "бик")
# X[:, 2] - все строки, 2-й столбец (количество "хрясь")
X_aak = X[:, 0]    # Координаты по оси X (количество "аак")
X_bik = X[:, 1]    # Координаты по оси Y (количество "бик")
X_hrjas = X[:, 2]  # Координаты по оси Z (количество "хрясь")

# Создаем список цветов для каждой точки
# Если метка (label) равна 1 (радостно) - зеленый цвет
# Если метка равна 0 (грустно) - красный цвет
# Это list comprehension - компактный способ создания списка
colors = ["green" if label == 1 else "red" for label in y]

# Рисуем точки на графике
# scatter() - функция для рисования точек
# X_aak, X_bik, X_hrjas - координаты точек
# c=colors - цвета точек
# s=60 - размер точек
# edgecolors="k" - черная обводка вокруг точек
ax.scatter(X_aak, X_bik, X_hrjas, c=colors, s=60, edgecolors="k")

# ===================================================================
# ЧАСТЬ 4: РИСОВАНИЕ ПЛОСКОСТИ РЕШЕНИЯ
# ===================================================================

# Получаем параметры обученной модели
# intercept_ - свободный член (смещение плоскости)
# coef_ - коэффициенты (веса) для каждого признака
w0 = model.intercept_[0]  # Свободный член
w1, w2, w3 = model.coef_[0]  # Коэффициенты для "аак", "бик", "хрясь"

# Определяем границы для рисования плоскости
# min() - минимальное значение, max() - максимальное
# Вычитаем и прибавляем 1, чтобы плоскость была немного больше графика
x_min, x_max = X_aak.min() - 1, X_aak.max() + 1
y_min, y_max = X_bik.min() - 1, X_bik.max() + 1

# Создаем сетку точек для рисования плоскости
# meshgrid создает две сетки координат (как шахматная доска)
# np.linspace создает 20 равномерно распределенных точек от min до max
xx, yy = np.meshgrid(
    np.linspace(x_min, x_max, 20),  # 20 точек по оси X
    np.linspace(y_min, y_max, 20)   # 20 точек по оси Y
)

# Вычисляем координаты Z для плоскости
# Формула плоскости: w0 + w1*x + w2*y + w3*z = 0
# Решаем относительно z: z = (-w0 - w1*x - w2*y) / w3
# 1e-9 - очень маленькое число, чтобы избежать деления на ноль
zz = (-w0 - w1 * xx - w2 * yy) / (w3 + 1e-9)

# Рисуем плоскость на графике
# plot_surface() - функция для рисования 3D поверхности
# alpha=0.3 - прозрачность (0 = полностью прозрачно, 1 = непрозрачно)
# color="blue" - синий цвет плоскости
ax.plot_surface(xx, yy, zz, alpha=0.3, color="blue")

# Подписываем оси графика
ax.set_xlabel("кол-во 'аак'")      # Название оси X
ax.set_ylabel("кол-во 'бик'")      # Название оси Y
ax.set_zlabel("кол-во 'хрясь'")    # Название оси Z
ax.set_title("3D + вращающаяся плоскость решения")  # Заголовок графика

# ===================================================================
# ЧАСТЬ 5: СОЗДАНИЕ АНИМАЦИИ ВРАЩЕНИЯ
# ===================================================================

# Функция инициализации анимации
# Вызывается один раз в начале анимации
def init():
    """
    Устанавливает начальный угол обзора графика
    """
    # view_init() - устанавливает угол обзора 3D графика
    # elev=20 - угол наклона по вертикали (elevation)
    # azim=30 - угол поворота по горизонтали (azimuth)
    ax.view_init(elev=20, azim=30)
    return fig,  # Возвращаем фигуру для анимации

# Функция анимации
# Вызывается для каждого кадра анимации
def animate(i):
    """
    Обновляет угол обзора для каждого кадра анимации
    
    Аргументы:
        i (int): номер кадра (от 0 до 359)
    """
    # Меняем угол поворота (azim) от 0 до 359 градусов
    # elev остается постоянным (20 градусов)
    # Когда i меняется от 0 до 359, график поворачивается на 360 градусов
    ax.view_init(elev=20, azim=i)
    return fig,  # Возвращаем обновленную фигуру

# Создаем анимацию
# FuncAnimation - функция для создания анимации
anim = animation.FuncAnimation(
    fig,           # Фигура, которую анимируем
    animate,       # Функция, которая вызывается для каждого кадра
    init_func=init,  # Функция инициализации
    frames=360,    # Количество кадров (360 = полный оборот)
    interval=30,   # Интервал между кадрами в миллисекундах (30 мс)
    blit=True      # Оптимизация: перерисовывать только измененные части
)

# ===================================================================
# ЧАСТЬ 6: ОТОБРАЖЕНИЕ ГРАФИКА
# ===================================================================

# Показываем график на экране
# В интерактивном режиме график будет вращаться
plt.show()

# ===================================================================
# ДОПОЛНИТЕЛЬНО: СОХРАНЕНИЕ АНИМАЦИИ В ФАЙЛ
# ===================================================================

# Если нужно сохранить анимацию в видео или GIF файл,
# раскомментируйте одну из следующих строк:

# Сохранение в MP4 видео (требует ffmpeg):
# anim.save("rotation.mp4", fps=30, extra_args=["-vcodec", "libx264"])

# Сохранение в GIF анимацию:
# anim.save("rotation.gif", fps=20)
